#!/bin/sh
# setup_subject_nifti_2
# shell script for creating new subject directories and automatically downloading and converting data
# new major version 2016 mds

################################################################################
#                                                                              #
# This script does basic fMRI preprocessing for one subject:                   #
#   Download the data.                                                         #
#   Convert it from dicom to NiFTI.                                            #
#   For BOLD scans perform:                                                    #
#     Motion correction with mcflirt.                                          #
#     Brain extraction with bet.                                               #
#     Diagnostics with melodic.                                                #
#   For anatomical (MPRAGE) scans perform:                                     #
#     Brain extraction with bet.                                               #
#   Optionally, a user-defined external script can be called on completion.    #
#                                                                              #
# In addtion to the standard Unix command line utilities it requires:          #
#   FSL      http://fsl.fmrib.ox.ac.uk/fsl/fslwiki/                            #
#   dcm2niix https://www.nitrc.org/plugins/mwiki/index.php/dcm2nii:MainPage    #
#   dcmdump  http://support.dcmtk.org/docs/dcmdump.html                        #
#                                                                              #
# If a Sun Grid Engine compatible scheduler is available                       #
# parts can be run in parallel.                                                #
#                                                                              #
################################################################################


################################################################################
# Initialize the basic settings.                                               #
################################################################################

ORIGINAL_COMMAND=$0
  for i in "$@"
  do 
    if [[ $i =~ " " ]] 
    then ORIGINAL_COMMAND=${ORIGINAL_COMMAND}" '$i'"
    else ORIGINAL_COMMAND=${ORIGINAL_COMMAND}" $i"
    fi
  done
DATE="`date +%Y%m%d_%H%M%S`"

DCMNII_CONVERTER='dcm2niix'
SGE_SETTINGS='/space/raid/linux/sge-root/FUNC_Grid/common/settings.sh'
FSLD_RAW_FILE='/space/raid/fmri/fsld/fsld_raw.R'
R_BIN='R'

USERNAME=`whoami`
HOSTNAME=`hostname -f`
STARTDIR=`pwd`
DICOM_SERVER=""
DICOM_USER=""
DICOM_BASEDIR=""

FSLVERSION=`which fsl | awk -F - '{print $2}'|awk -F . '{print $1}'`
DEFAULT_FILETYPE='NIFTI_GZ'
FSLOUTPUTTYPE=$DEFAULT_FILETYPE
IMG_SUFFIX='.nii.gz'
FSL_OPT_FILE=""
MCFLIRT_ARGS="-plots -report -stages 4 -sinc_final"
MELODIC_ARGS="--report"

TESTMODE=0
DOSCP="skip"
DODEBABELER="do"
DELETE_DICOM="skip"
DB_DOWNLOAD="skip"
BOLDTAG='AUTO_SELECT_NOT_TAG'
MPRAGE_TAG='AUTO_SELECT_NOT_TAG'
RUN_MCFLIRT="do"
RUN_BET="do"
RUN_MELODIC="do"
PROCESS_ANAT="do"
R_DIAGNOSTICS="do"
SGE_RESUBMIT="do"
PROCESS_LIST="ALL"
EXSCRIPT=''
FORSPM=0

USAGE="
USAGE: setup_subject_nifti_2 --download hostname,account,directory base_dir subject

Download and preprocess the fMRI data for one subject.

Required arguments:
  base_dir: the project directory in which the subject's directory will be created
  subject:  the subject code that was entered when scanning

Optional arguments:
  -g, --download
     hostname:  the hostname of the dicom server
         ccn  = dcm.semel.ucla.edu
         bmap = dns0.bmap.ucla.edu
     account:   the name of your account on the dicom server
     directory: the group directory in which the subject's directory resides
  -s, --skip    comma delimited list of steps to skip
  -d, --do      comma delimited list of steps to do (or unskip)
     mcflirt      run mcflirt on BOLD scans,    defaults to: $RUN_MCFLIRT
     bet          run bet     on BOLD scans,    defaults to: $RUN_BET
     melodic      run melodic on BOLD scans,    defaults to: $RUN_MELODIC
     mprage       process  anatomical scans,    defaults to: $PROCESS_ANAT
     debabel      convert dicom files to nifti, defaults to: $DODEBABELER with $DCMNII_CONVERTER
     sge          use the Sun Grid Engine,      defaults to: $SGE_RESUBMIT
  -f, --mcflirt  mcflirt arguments, defaults to:  $MCFLIRT_ARGS
  -m, --melodic  melodic arguments, defaults to:  $MELODIC_ARGS
  -p, --process  list of series to process
  -x, --xscript  external script to run after all processing setps are complete
"

if [ $# -eq 0 ]
then
  echo "$USAGE"
  exit
fi


################################################################################
# Parse the arguments.                                                         #
################################################################################

while [ $# -gt 2 ]
do
  case $1 in
    -g|--download) #echo "Get = $2"
                   DOSCP="do"
                   DICOM_SERVER=` echo $2 | cut -d, -f 1`
                   DICOM_USER=`   echo $2 | cut -d, -f 2`
                   DICOM_BASEDIR=`echo $2 | cut -d, -f 3`
                   shift; shift
                   ;;
    -d|--do)       #echo "Do = $OPTARG"
                   IFS=","
                   for i in $2; do 
                     case "$i" in
                       debabel) DODEBABELER="do";;
                       mcflirt) RUN_MCFLIRT="do";;
                       melodic) RUN_MELODIC="do";;
                       bet)     RUN_BET="do";;
                       mprage)  PROCESS_ANAT="do";;
                       sge)     SGE_RESUBMIT="do";;
                     esac
                   done
                   unset IFS
                   shift; shift
                   ;;
    -s|--skip)     #echo "Skip = $2"
                   IFS=","
                   for i in $2; do 
                     case "$i" in
                       debabel) DODEBABELER="skip";;
                       mcflirt) RUN_MCFLIRT="skip";;
                       melodic) RUN_MELODIC="skip";;
                       bet)     RUN_BET="skip";;
                       mprage)  PROCESS_ANAT="skip";;
                       sge)     SGE_RESUBMIT="skip";;
                     esac
                   done
                   unset IFS
                   shift; shift
                   ;;
    -f|--mcflirt) MCFLIRT_ARGS=$2;shift; shift;;
    -m|--melodic) MELODIC_ARGS=$2;shift; shift;;
    -p|--process) PROCESS_LIST=`echo $2 | sed s/,/" "/g`;shift; shift;;
    -x|--xscript) EXSCRIPT=$2;    shift; shift;;
    *)            echo $1; shift;;
  esac
done

BASEDIR=$1
SUBCODE=$2
if [ ! -d $BASEDIR -o ! -w $BASEDIR ]
then
  echo -e "\n$BASEDIR is not a directory or is not writeable.  Exiting.\n"
  exit
else
  cd $BASEDIR
  BASEDIR=`pwd`
fi
SUBDIR="${BASEDIR}/$SUBCODE"

if [ X$DICOM_SERVER = "Xccn"  ]; then DICOM_SERVER="dcm.semel.ucla.edu"; fi
if [ X$DICOM_SERVER = "Xbmap" ]; then DICOM_SERVER="dns0.bmap.ucla.edu"; fi

# if the sge is requested, can it be set? or is it already available?
if [ $SGE_RESUBMIT = "do" ]
then
  if [ -r $SGE_SETTINGS ]; then . $SGE_SETTINGS; fi
  [ "X"$SGE_ROOT != "X" ];      HAVESGER=$?
  which qsub > /dev/null  2>&1; HAVEQSUB=$?
  HAVESGE=`expr $HAVESGER + $HAVEQSUB`
  if [ $HAVESGE -gt 0 ]
  then
    echo -e "\nSGE requested but not available. Running locally."
    SGE_RESUBMIT="skip"
  fi
fi


################################################################################
# Setup the subject directory and start logging.                               #
################################################################################

if [ X$REQUEST != "X" ]
  then 
  echo "executing on grid node "`hostname`":" `date`
  echo "${ORIGINAL_COMMAND}"
fi

echo ""
DIRLIST=""

if [ -d $SUBDIR ]
then
  echo "$SUBDIR already exists."
else
  echo "Making ${SUBDIR}"
  DIRLIST="$DIRLIST
Making $SUBDIR"
  mkdir $SUBDIR
fi

for i in dicom raw behav analysis notes
  do if [ -d $SUBDIR/$i ]
     then
       echo "$SUBDIR/$i already exists."
     else
       echo "Making $SUBDIR/$i" 
       DIRLIST="$DIRLIST
Making $SUBDIR/$i"
       mkdir $SUBDIR/$i
     fi
done

# set up the log file (unless we are running on the grid)
if [ ! $SGE_TASK_ID ]
then
  LOGFILE="${SUBDIR}/notes/setup_log.${DATE}"
  echo -e "\nLogging command output to:\n$LOGFILE\n"
else
  LOGFILE="/dev/null"
fi

# echo some info to the log file
echo "$ORIGINAL_COMMAND
"  > $LOGFILE
echo "DATE          "`date "+%F %T %Z"` >> $LOGFILE
echo "USERNAME      $USERNAME"          >> $LOGFILE
echo "HOSTNAME      $HOSTNAME"          >> $LOGFILE
echo "DIRECTORY     $STARTDIR"          >> $LOGFILE
echo "TESTMODE      $TESTMODE"          >> $LOGFILE
echo "SGE_RESUBMIT  $SGE_RESUBMIT"      >> $LOGFILE
echo "BASEDIR       $BASEDIR"           >> $LOGFILE
echo "SUBCODE       $SUBCODE"           >> $LOGFILE
echo "SUBDIR        $SUBDIR"            >> $LOGFILE
echo "DOSCP         $DOSCP"             >> $LOGFILE
echo "DICOM_SERVER  $DICOM_SERVER"      >> $LOGFILE
echo "DICOM_USER    $DICOM_USER"        >> $LOGFILE
echo "DICOM_BASEDIR $DICOM_BASEDIR"     >> $LOGFILE
echo "BOLDTAG       $BOLDTAG"           >> $LOGFILE
echo "MPRAGE_TAG    $MPRAGE_TAG"        >> $LOGFILE
echo "DODEBABELER   $DODEBABELER"       >> $LOGFILE
echo "RUN_MCFLIRT   $RUN_MCFLIRT"       >> $LOGFILE
echo "MCFLIRT_ARGS  $MCFLIRT_ARGS"      >> $LOGFILE
echo "RUN_BET       $RUN_BET"           >> $LOGFILE
echo "RUN_MELODIC   $RUN_MELODIC"       >> $LOGFILE
echo "MELODIC_ARGS  $MELODIC_ARGS"      >> $LOGFILE
echo "PROCESS_ANAT  $PROCESS_ANAT"      >> $LOGFILE
echo "PROCESS_LIST  $PROCESS_LIST"      >> $LOGFILE
echo "EXSCRIPT      $EXSCRIPT"          >> $LOGFILE
echo "$DIRLIST "                        >> $LOGFILE


if [ $TESTMODE -eq 1 ]
then 
  echo "BASEDIR       = $BASEDIR"
  echo "SUBCODE       = $SUBCODE"
  echo "DOSCP         = $DOSCP"
  echo "DICOM_SERVER  = $DICOM_SERVER"
  echo "DICOM_USER    = $DICOM_USER"
  echo "DICOM_BASEDIR = $DICOM_BASEDIR"
  echo "DODEBABELER   = $DODEBABELER"
  echo "RUN_MCFLIRT   = $RUN_MCFLIRT"
  echo "RUN_BET       = $RUN_BET"
  echo "RUN_MELODIC   = $RUN_MELODIC"
  echo "PROCESS_ANAT  = $PROCESS_ANAT"
fi


################################################################################
# Download the data from the remote server.                                    #
################################################################################

if [ $TESTMODE -eq 0 ]
then
  echo "" | tee -a $LOGFILE
  if [ $DOSCP = "do" ]
  then
    if [ -d $SUBDIR/dicom ]
    then

      echo "copying data from ${DICOM_SERVER} using scp..." | tee -a $LOGFILE
      COMMAND="scp -qpr ${DICOM_USER}@${DICOM_SERVER}:${DICOM_BASEDIR}/$SUBCODE $SUBDIR/dicom"
      echo $COMMAND >> $LOGFILE
      $COMMAND >> $LOGFILE 2>&1
      sync

      if [ $? -ne 0 ]
      then
        n1=`wc -l $LOGFILE | awk '{print $1}'`
        n2=`grep -n "scp -qpr" $LOGFILE | awk -F: '{print $1}'`
        tail -`expr $n1 - $n2` $LOGFILE
        echo "" | tee -a $LOGFILE
        echo "the copy appears to have failed. exiting..." | tee -a $LOGFILE
        exit
      fi

      # the -p option to scp preserves the time stamps, but the files should have the local permissions
      echo -e "\nadjusting file ownerships and permissions" | tee -a $LOGFILE
      dgrp=`stat -c "%G" $SUBDIR/dicom`
      dprm=`stat -c "%a" $SUBDIR/dicom`
      fprm=`stat -c "%a" $LOGFILE`
      echo "find $SUBDIR/dicom         ! -group $dgrp -exec chgrp $dgrp {} \;" >> $LOGFILE
            find $SUBDIR/dicom         ! -group $dgrp -exec chgrp $dgrp {} \;  >> $LOGFILE 2>&1
      echo "find $SUBDIR/dicom -type d ! -perm  $dprm -exec chmod $dprm {} \;" >> $LOGFILE
            find $SUBDIR/dicom -type d ! -perm  $dprm -exec chmod $dprm {} \;  >> $LOGFILE 2>&1
      echo "find $SUBDIR/dicom -type f ! -perm  $fprm -exec chmod $fprm {} \;" >> $LOGFILE
            find $SUBDIR/dicom -type f ! -perm  $fprm -exec chmod $fprm {} \;  >> $LOGFILE 2>&1

      # create a compressed archive of the data
      if [ ! -e $SUBDIR/dicom.tar.gz ]
       then DCMTARNAME="dicom.tar.gz"
       else DCMTARNAME="dicom-"$DATE".tar.gz"
      fi
      cd $SUBDIR
      echo "creating data archive:  $DCMTARNAME" | tee -a $LOGFILE
      tar zcf $DCMTARNAME dicom
      # unless conversion is requested, delete the uncompressed data
      if [ $DODEBABELER = "skip" ]
      then
        echo "format conversion not reqested, deleting unarchived dicom files" | tee -a $LOGFILE
        rm -r $SUBDIR/dicom
      fi

    else
      echo "$SUBDIR/dicom does not exist! exiting..." | tee -a $LOGFILE
      exit
    fi
  else
    echo "skipping download, assuming existing data" | tee -a $LOGFILE
  fi
fi


################################################################################
# Set up a function to compose a command for submission to the SGE.            #
################################################################################

# rewrite the command for submission to the grid
sge_rewrite()
{
  DO=""
  if [ $SGE_RESUBMIT = "do"   ]; then   DO="sge";           fi
  if [ $DODEBABELER  = "do"   ]; then   DO="$DO,debabel";   fi
  if [ $RUN_MCFLIRT  = "do"   ]; then   DO="$DO,mcflirt";   fi
  if [ $RUN_BET      = "do"   ]; then   DO="$DO,bet";       fi
  if [ $RUN_MELODIC  = "do"   ]; then   DO="$DO,melodic";   fi
  if [ $PROCESS_ANAT = "do"   ]; then   DO="$DO,mprage";    fi
  DO=`echo $DO     | sed 's/^,//'`

  SKIP=""
  if [ $SGE_RESUBMIT = "skip" ]; then SKIP="sge";           fi
  if [ $DODEBABELER  = "skip" ]; then SKIP="$SKIP,debabel"; fi
  if [ $RUN_MCFLIRT  = "skip" ]; then SKIP="$SKIP,mcflirt"; fi
  if [ $RUN_BET      = "skip" ]; then SKIP="$SKIP,bet";     fi
  if [ $RUN_MELODIC  = "skip" ]; then SKIP="$SKIP,melodic"; fi
  if [ $PROCESS_ANAT = "skip" ]; then SKIP="$SKIP,mprage";  fi
  SKIP=`echo $SKIP | sed 's/^,//'`

  COMMAND=$0
  if [ "X$DO"       != "X" ]; then COMMAND="$COMMAND --do $DO";                fi
  if [ "X$SKIP"     != "X" ]; then COMMAND="$COMMAND --skip $SKIP";            fi
  COMMAND="$COMMAND --mcflirt '"$MCFLIRT_ARGS"' --melodic '"$MELODIC_ARGS"'"
  COMMAND="$COMMAND --process "$PROCESS_LIST
  if [ "X$EXSCRIPT" != "X" ]; then COMMAND="$COMMAND --xscript '"$EXSCRIPT"'"; fi
  COMMAND="$COMMAND $BASEDIR $SUBCODE"
  #echo $COMMAND
}


################################################################################
# If the SGE is requested and we're not already on it, resubmit the job there. #
################################################################################

if [ $SGE_RESUBMIT = "do" -a X$REQUEST = "X" ]
then
  sge_rewrite

  #echo $COMMAND
  echo ""                                       | tee -a $LOGFILE
  echo "--------------------------------------" | tee -a $LOGFILE
  echo "submitting remaining tasks to the grid" | tee -a $LOGFILE

  n="setup_$SUBCODE"
  qs=`qsub -cwd -j y -o $LOGFILE -N $n -r no -b y sh $COMMAND`
  echo -e "$qs\n"`date`                         | tee -a $LOGFILE
  jn=`echo $qs | awk '{print $3}'`

  echo "--------------------------------------" | tee -a $LOGFILE
  echo ""                                       | tee -a $LOGFILE
  sync
  echo "To view progress, run: tail -f $LOGFILE"
  echo ""
  exit
fi

################################################################################
# Convert the data from Dicom to NiFTI                                         #
################################################################################

if [ $TESTMODE -eq 0 -a $DODEBABELER = "do" ]
then
  echo ""                                                       | tee -a $LOGFILE
  echo "----------"                                             | tee -a $LOGFILE
  echo ""                                                       | tee -a $LOGFILE
  echo "Converting DICOM to NIfTI using ${DCMNII_CONVERTER}..." | tee -a $LOGFILE
  echo ""                                                       | tee -a $LOGFILE

  # check for dicom files, and untar them if needed
  NEEDSUNTAR=0
  cd $SUBDIR
  if [ -e dicom ]
  then
    if [ -d dicom ]
    then
      if [ "X"`find dicom -maxdepth 0 -type d -empty` != "X" ]; then NEEDSUNTAR=1; fi
    else
      echo "$SUBDIR/dicom exists but is not a directory, exiting" | tee -a $LOGFILE
      exit
    fi
  else NEEDSUNTAR=1
  fi
  if [ $NEEDSUNTAR = 1 ]
  then
    echo "$SUBDIR/dicom does not exist or is empty, looking for archives" | tee -a $LOGFILE
    DCMTARNAME=`find . -maxdepth 1 -type f -name "dicom*.tar.gz" | awk 'END{print $0}'`
    if [ "X$DCMTARNAME" != "X" ]
    then
      echo "extracting $DCMTARNAME"
      tar zxf $DCMTARNAME
    else
      echo "no archives found either, exiting" | tee -a $LOGFILE
      exit
    fi
  fi

  # setup a debabel directory
  if [ -e $SUBDIR/debabel ]; then rm -r $SUBDIR/debabel; fi
  echo "mkdir $SUBDIR/debabel" | tee -a $LOGFILE; mkdir $SUBDIR/debabel

  # get a name for the coversion log
  if [ $SGE_STDOUT_PATH ]
    then CONVLOG="$SGE_STDOUT_PATH-convert.log"
    else CONVLOG="$LOGFILE-convert.log"
  fi

  #  use dcm2nii to convert entire dicom dir into the debabel directory
  echo "cd $SUBDIR/dicom" | tee -a $LOGFILE;  cd $SUBDIR/dicom
  if [ $FSLOUTPUTTYPE == "NIFTI_GZ" ]
    then COMMAND="$DCMNII_CONVERTER -b y -t n -v y -s n -z y -f %t_%p_%s -o ../debabel *"
    else COMMAND="$DCMNII_CONVERTER -b y -t n -v y -s n -z n -f %t_%p_%s -o ../debabel *"
  fi
  echo $COMMAND | tee -a $LOGFILE
  $COMMAND      > $CONVLOG
  echo "Conversion details logged to $CONVLOG." | tee -a $LOGFILE
  echo "Partial output:" | tee -a $LOGFILE
  echo "" | tee -a $LOGFILE
  awk 'BEGIN{p=1;q=0} /^Converting /{p=1;q=0} /^[0-9]/{q=1} (p==1) && (q!=1){print} /^Found/{p=0}' $CONVLOG | tee -a $LOGFILE

  # this gets messy now, because we have to account for the possibility that there may be
  # duplicate sequence names on different days, or with different protocols or something,
  # and dcm2nii sometimes makes more than one file from a sequence

  # dump the naming information from the dicom files
  awk '/^Converting /{ \
    dfn=substr($0,index($0,$2));
    #print dfn; \
    cm="dcmdump +P StudyDate +P StudyTime +P ProtocolName +P SeriesDescription +P SeriesNumber " \
               "+P ScanningSequence +P SequenceVariant +P ImageType \"" dfn "\""; \
    while ((cm | getline ) > 0){ \
      #print $0; \
      {split($0,a,"(\\[|\\])");x=a[2];gsub(/ |\/|\(|\)/,"_",x);gsub("&","+",x)} \
      #print x; \
      if($NF=="StudyDate"){        td=x} \
      if($NF=="StudyTime"){        tt=sprintf("%06d",x+0.5)} \
      if($NF=="ProtocolName"){     sp=x} \
      if($NF=="SeriesDescription"){sd=x} \
      if($NF=="SeriesNumber"){     sn=x} \
      if($NF=="ScanningSequence"){ ss=x} \
      if($NF=="SequenceVariant"){  sv=x} \
      if($NF=="ImageType"){        it=x} \
    } close(cm); \
    print dfn, td tt, sp, sd, sn,ss, sv, it; \
  }' $CONVLOG > ../debabel/convert.info

  # look for duplicate sequence names
  NSDATES=`awk '{print $2}' ../debabel/convert.info | sort -u | wc -l`
  echo "" | tee -a $LOGFILE
  if [ $NSDATES -eq 1 ]
   then echo "only one study date found, using short names" | tee -a $LOGFILE
   else echo "multiple study dates found, using extended names" | tee -a $LOGFILE
  fi

  # generate the directory/file names
  awk -v nsdates=$NSDATES -v subdir=$SUBDIR '{ \
    fni=$2 "_" $3 "_" $5; \
    fno=$4; if(fno=="MoCoSeries"){fno=$3"_"fno}; fno=fno "_" $5; if(nsdates>1){fno=$2"_"fno}; \
    print $1, fni, fno, $6, $7, $8}' ../debabel/convert.info > ../debabel/convert.names

  echo "" | tee -a $LOGFILE
  echo "cd $SUBDIR/raw" | tee -a $LOGFILE;  cd $SUBDIR/raw

  # create the "raw" directories and move the files into them
  for i in `awk '{print $3}' ../debabel/convert.names | sort -u`
    do echo "mkdir $i"  | tee -a $LOGFILE; mkdir $i
       for j in `awk -v i=$i '($3==i){print $2}' ../debabel/convert.names | sort -u`
         do for k in ../debabel/$j*
              do l=`echo $k | sed s/.*$j/$i/`
                 echo "  mv $k $i/$l"  | tee -a $LOGFILE; mv $k $i/$l
            done
       done
  done

  # add the dicom path files
  echo ""  | tee -a $LOGFILE
  echo "adding dicom path files" | tee -a $LOGFILE
  awk '{print "echo \""$1"\" >> "$3"/dicom-path.txt";system("echo \""$1"\" >> "$3"/dicom-path.txt")}' ../debabel/convert.names

  # mark the ones that look like BOLD or MRAGE scans
  echo "" | tee -a $LOGFILE
  echo "marking apparent BOLD and MPRAGE scans" | tee -a $LOGFILE
  awk '($4=="EP"     && $5~/^SK/ && $6!~/DIFFUSION/){ \
         print $3 " Sequence/Variant/Type = "$4" "$5" "$6" : touch " $3 "/isBOLD";   system("touch "$3"/isBOLD")} \
       ($4=="GR\\IR" && $5~/SP\\MP/                ){ \
         print $3 " Sequence/Variant/Type = "$4" "$5" "$6" : touch " $3 "/isMPRAGE"; system("touch "$3"/isMPRAGE")}' \
      ../debabel/convert.names | tee -a $LOGFILE

  # remove the debabel directory, and mark coversion as no longer needed
  rm -r ../debabel
  DODEBABELER="skip"

  # make sure the dicom data are archived, then delete the uncompressed data
  cd $SUBDIR
  echo "" | tee -a $LOGFILE
  if [ "X$DCMTARNAME" = "X" ]
  then
    for i in `find . -maxdepth 1 -name "dicom*.tar.gz"`
    do
      tar zdf $i dicom > /dev/null 2>&1
      if [ $? -eq 0 ]; then DCMTARNAME=$i; break; fi
    done
  fi
  if [ "X$DCMTARNAME" = "X" ]
  then
    DCMTARNAME="dicom.tar.gz"
    if [ -e $DCMTARNAME ]; then DCMTARNAME="dicom-"$DATE".tar.gz"; fi
    echo -e "creating data archive:  $DCMTARNAME" | tee -a $LOGFILE
    tar zcf $DCMTARNAME dicom
  else
    echo "dicom data already archived as $DCMTARNAME" | tee -a $LOGFILE
  fi
  if [ "X$DCMTARNAME" != "X" -a -e $DCMTARNAME ]
  then
    echo -e "deleting dicom directory" | tee -a $LOGFILE
    rm -r $SUBDIR/dicom
  fi

else echo "skipping DICOM to NIfTI conversion" | tee -a $LOGFILE
fi


################################################################################
# Run the analysis steps                                                       #
################################################################################

# recompose the list
case $PROCESS_LIST in
  ALL ) PROCESS_LIST=`find $SUBDIR/raw -name isBOLD -o -name isMPRAGE | awk -F/ '{print $(NF-1)}'`;;
  NONE) PROCESS_LIST=""; echo "skipping series processing" | tee -a $LOGFILE;;
esac

# if requested, submit the processing as separate jobs, then exit
if [ $SGE_RESUBMIT = "do" ]
then
  echo ""                                       | tee -a $LOGFILE
  echo "----------"                             | tee -a $LOGFILE
  echo ""                                       | tee -a $LOGFILE
  echo "submitting processing jobs to the grid" | tee -a $LOGFILE
  echo ""                                       | tee -a $LOGFILE
  SGE_RESUBMIT="skip"
  EXSCRIPT_HOLD=$EXSCRIPT; EXSCRIPT=""
  jn=$JOB_ID
  PL=$PROCESS_LIST
  for series in $PL
  do
    echo -e "$series : \c" | tee -a $LOGFILE
    PROCESS_LIST=$series
    sge_rewrite
    SLF=${SGE_STDOUT_PATH}"_tmp_"${series}
    n=${JOB_NAME}"_"${series}
    #echo "qsub -cwd -j y -o $SLF -N $n -r no -b y sh $COMMAND"
    qs=`qsub -cwd -j y -o $SLF -N $n -r no -b y sh $COMMAND`
    echo "$qs"           | tee -a $LOGFILE
    jn="${jn},"`echo $qs | awk '{print $3}'`
  done
  #echo "job number list:  $jn"
  EXSCRIPT=$EXSCRIPT_HOLD
  PROCESS_LIST="NONE"
  sge_rewrite
  n=${JOB_NAME}"_finish"
  #echo "qsub -cwd -j y -o $SGE_STDOUT_PATH -N $n -r no -b y -hold_jid $jn sh $COMMAND"
  qsub -cwd -j y -o $SGE_STDOUT_PATH -N $n -r no -b y -hold_jid $jn sh $COMMAND
  echo -e "\nwaiting for processing jobs to complete:" `date` "\n" | tee -a $LOGFILE
  sync
  exit
fi   



for series in $PROCESS_LIST
do
  echo -e "\nProcessing $series"

  if [ -e $SUBDIR/raw/$series/isBOLD ]
  then

    cd $SUBDIR/raw/$series

    # run mcflirt
    if [ $RUN_MCFLIRT = "do" -a $TESTMODE -eq 0 ]
    then
      echo ""                | tee -a $LOGFILE
      echo "running mcflirt" | tee -a $LOGFILE
      FOUR_D_FILENAME=$series$IMG_SUFFIX
      COMMAND="mcflirt -in $FOUR_D_FILENAME $MCFLIRT_ARGS"
      echo $COMMAND | tee -a $LOGFILE
      $COMMAND
    fi

    # run bet
    if [ $RUN_BET = "do" -a $TESTMODE -eq 0 ]
    then
      echo ""            | tee -a $LOGFILE
      echo "running BET" | tee -a $LOGFILE
      MCF_FILENAME="./"$series"_mcf"$IMG_SUFFIX
      if [ ! -f $MCF_FILENAME ]
      then
        echo "$MCF_FILENAME does not exist, trying original file" | tee -a $LOGFILE
        MCF_FILENAME="./"$series$IMG_SUFFIX
      fi
      # remove file extension since BET wants stems only
      MCF_FILENAME=`echo "${MCF_FILENAME}" | sed " s/$IMG_SUFFIX// "`    
      BET_FILENAME="${MCF_FILENAME}_brain"
      COMMAND="bet $MCF_FILENAME $BET_FILENAME -m -F"
      echo $COMMAND | tee -a $LOGFILE
      $COMMAND
    fi

    if [ $RUN_MELODIC = "do" -a $TESTMODE -eq 0 ]
    then
      echo ""                | tee -a $LOGFILE
      echo "running MELODIC" | tee -a $LOGFILE
      MCF_FILENAME=${series}"_mcf_brain"$IMG_SUFFIX
      if [ ! -f $MCF_FILENAME ]
      then
        echo "$MCF_FILENAME does not exist, trying mcf file"
        MCF_FILENAME=${series}"_mcf"$IMG_SUFFIX
      fi
      if [ ! -f $MCF_FILENAME ]
      then
        echo "$MCF_FILENAME does not exist, trying original 4D file"
        MCF_FILENAME=${series}$IMG_SUFFIX
      fi
      if [ ! -f $MCF_FILENAME ]
      then
        echo "$MCF_FILENAME does not exist, no suitable file found"
      fi
      if [ -f $MCF_FILENAME ]
      then
        COMMAND="melodic  $MELODIC_ARGS -i $MCF_FILENAME"
        echo $COMMAND | tee -a $LOGFILE
        $COMMAND
      fi
    fi

#    if [ $R_DIAGNOSTICS = "do" -a  $TESTMODE -eq 0 ]
#    then
#      echo ""                      | tee -a $LOGFILE
#      echo "running R diagnostics" | tee -a $LOGFILE
#      cd $SUBDIR/raw/$series
#      MCF_FILENAME=$series"_mcf"$IMG_SUFFIX
#      if [ ! -s $MCF_FILENAME ]
#      then
#        echo "$MCF_FILENAME does not exist, skipping this run"
#        continue
#      fi
#      COMMAND="fmriqa.py $MCF_FILENAME"
#      echo $COMMAND | tee -a $LOGFILE
#      $COMMAND
#    fi

  fi  # closes:  if isBOLD

  if [ -e $SUBDIR/raw/$series/isMPRAGE ]
  then
    cd $SUBDIR/raw/$series
    if [ $PROCESS_ANAT = "do" -a $TESTMODE -eq 0 ]
      then
        echo ""                   | tee -a $LOGFILE
        echo "processing MP-RAGE" | tee -a $LOGFILE
        ln -s $series$IMG_SUFFIX "mprage$IMG_SUFFIX"
        echo "Running bet with -B option (for neck cleanup)."
        COMMAND="bet mprage mprage_brain -B -f 0.33" 
        echo $COMMAND
        $COMMAND
    fi
  fi


  echo -e "\n$series completed"
done  # closes for PROCESS_LIST


# if we are processing a series separtately, we need to exit now
if [[ $SGE_STDOUT_PATH =~ "_tmp_"$series ]]; then exit; fi

# since we are now back from processing all the series, 
# we need to copy their output to the main log file
echo -e "\n==========\n\nmerging proccessing output files"
for i in ${SGE_STDOUT_PATH}"_tmp_"*
do if [ -e $i ]; then echo -e "\n----------\n"; cat $i; rm $i; fi
done
echo -e "\n=========="
sync


################################################################################
# Run requested external script, and complete.                                 #
################################################################################

if [ -n "$EXSCRIPT" ]
  then
   cd $SUBDIR
   echo ""                                     | tee -a $LOGFILE
   echo "----------"                           | tee -a $LOGFILE
   echo ""                                     | tee -a $LOGFILE
   echo "running requested external script..." | tee -a $LOGFILE
   echo ${EXSCRIPT}                            | tee -a $LOGFILE
   echo ""                                     | tee -a $LOGFILE
   set -a
   ${EXSCRIPT} | tee -a $LOGFILE
fi

# note completion time
echo -e "\n\n----------\n\ncommand complete:" `date` | tee -a $LOGFILE

exit

